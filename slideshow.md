---
marp: true
author: Emil Fresk
size: 16:9
theme: uncover
paginate: true
class: invert
footer: "Emil Fresk, PhD - Mobilaris Industrial Solutions"
style: |
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
---

### `async` + RTIC = :heart:

##### Solving RTIC's fatal flaw

![width:250px](me.jpg)

###### By Emil Fresk 

---

## I am

##### Rust power-user in embedded systems and mathematics

##### Member of the Rust Embedded Working Group

##### Contributor/maintainer of RTIC (rtic.rs)

...

---

##### For RTIC

- Writing generic libraries is hard
- Writing generic tasks is very hard
- Writing drivers using multiple interrupts generically is super hard


---

##### "Simple" example

<span style="font-size:60%">

```rust
#[task(priority = 7)]
fn high_prio_read_radio_packet(cx: high_prio_read_radio_packet::Context) {
    // 1. Wait for radio event interrupt
    // 2. Start SPI DMA transaction to read status register
    // 3. Get SPI Done event
    // 4. Check if there was a radio packet
    // 5. Start SPI DMA transaction to read radio packet
    // 6. Get SPI Done event
    // ...
    // N-1. Maybe Send and answer to radio packet ...
    // N. Loop
}

#[task(binds = GPIOTE, priority = 7)]
fn radio_event(cx: radio_event::Context) {
    // On interrupt tell `read_radio_packet` to check the
    // radio IC's status register
}

#[task(binds = DMA1, priority = 7)]
fn spi_dma_handling(cx: spi_dma_handling::Context) {
    // Handle DMA done
}

#[task(binds = SPI1, priority = 7)]
fn spi_handling(cx: spi_handling::Context) {
    // Handle the overall SPI transaction
}
``` 

</span>

---

##### Some issues

- We can't
  - easily write code to read the radio packet without blocking
  - break out the driver into a standalone crate for reuse
  - understand what this is doing after it is done (enormous state-machine)

---

##### But... is this a common issue?

---

##### What if all this could be linear code?

<span style="font-size:70%">

```rust
#[task(local = [radio_driver, radio_event], priority = 7)]
async fn radio_handling(cx: radio_handling::Context) {
    let mut radio = cx.local.radio_driver;
    let mut radio_event = cx.local.radio_driver;
    
    loop {
        radio_event.wait_for_event().await;
        
        let msg = match radio.read_packet().await {
            Ok(msg) => msg,
            Err(_) => {
                radio.send_packet("error receiving").await;
                continue;
            }
        }
        
        // ...
    }
}

// Look! No hardware tasks anymore!
// Interrupt handling is baked into the `async` drivers
```

</span>

---

##### RTIC's `async` support

- You can
  - easily write code to read the radio packet without blocking
  - easily break out the driver into a standalone crate for reuse
  - understand what this is doing after it is done (simple linear code)

###### No need to let RTIC handle the interrupts!

---

##### What `async` really does

```rust
async fn foo() -> u32 {
    // ...
}

// is transformed into

fn foo() -> impl Future<Output = u32> {
    // ...
}
```

---

##### The `Future` trait and `Poll`

```rust
pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T), // The future has completed
    Pending, // The future is still running
}
```

###### Implementing `Future` means that something can be `Poll`ed

---

##### `.await` - the statemachine generator

```rust
async fn bar() {
    // ...
}

async fn baz() -> u32 {
    // ...
}

async fn foo() -> u32 {
    // This becomes a linear state machine
    bar().await;
    baz().await
}
```

---

##### Async executors polls `Future`s

```rust
async fn foo() {
    // ...
}

#[tokio::main]
async fn main() {
    // Give the future generated by `foo()` to 
    // `tokio` (popular async executor) and wait
    // for it to finish
    tokio::spawn(foo()).await;
}
```

---

##### `Waker`, or how executors knows when to poll

###### The `Context` in a `Future` holds the link to the executor via an `Waker`.

```rust
pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

```rust
// Get the waker which will tell the executor to continue executing this future
let waker = cx.waker(); // gives an `&Waker`
```

```rust
// Call `wake()` which will tell the executor that this future needs to be polled
waker.wake() // gives an `&Waker`
```

---

##### To summarize

<span style="font-size:75%">

- Things that can be polled implement `Future` to work with `async`
- Executors is the underlying thing that polls futures as needed
- Wakers signal executors that a specific future needs polling

</span>

---

##### How to write an sync driver

To the repository!

---

##### The async ecosystem

- `embedded-hal-async` async traits for hardware (SPI, I2C, Digital)

